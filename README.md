# はじめに
これは「デートがマンネリ化したカップルにランダムで一つデートプランを提示する」アプリのためのバックエンドAPIである。

ランダムである以上ユーザーごとに何か対応する必要がないため、叩けるAPIはランダムにデートプランが出てくる `/datePlan/` のみである。

そして僕のアイデアがたまるまでランダム化するほど件数が稼げないため、この単純さを活かして「SQL文によるDBの性能改善」をテーマとしたポートフォリオに転用することにした。


# 環境
- OS: macOS
- Language: GO version go1.25.6 darwin/arm64
- Database: SQLite3 (modernc.org/sqlite)
- editor: VScode + Go Extension
- Loat Test: hey

# 目次
- 2/16: MVPの実装。
- 2/17: B-tree、SQL発行回数削減によるパフォーマンス改善。
- 2/20: SQL文変更による欠番への対処とページキャッシュを用いたパフォーマンスの維持。

## 2/16　MVPの実装。
MVP(`/datePlan/` のみ)の実装。First commit.

## 2/17　B-tree、SQL発行回数削減によるパフォーマンス改善。
```
Summary:
  Total:        436.5398 secs
  Slowest:      12.5233 secs
  Fastest:      8.5823 secs
  Average:      11.7876 secs
  Requests/sec: 4.2310
  
  Total data:   379574 bytes
  Size/request: 205 bytes

Response time histogram:
  8.582 [1]     |
  8.976 [1]     |
  9.370 [1]     |
  9.765 [3]     |
  10.159 [4]    |
  10.553 [4]    |
  10.947 [13]   |■
  11.341 [22]   |■
  11.735 [733]  |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  12.129 [896]  |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  12.523 [169]  |■■■■■■■■


Latency distribution:
  10%% in 11.6198 secs
  25%% in 11.6806 secs
  50%% in 11.7621 secs
  75%% in 11.9052 secs
  90%% in 12.1158 secs
  95%% in 12.1959 secs
  99%% in 12.3350 secs

Details (average, fastest, slowest):
  DNS+dialup:   0.0001 secs, 0.0000 secs, 0.0055 secs
  DNS-lookup:   0.0000 secs, 0.0000 secs, 0.0019 secs
  req write:    0.0000 secs, 0.0000 secs, 0.0005 secs
  resp wait:    11.7874 secs, 8.5823 secs, 12.5232 secs
  resp read:    0.0000 secs, 0.0000 secs, 0.0021 secs

Status code distribution:
  [200] 1847 responses
  ```
以上は合計アクセス数1847件、同時接続数50人の場合の負荷テストの結果である。
`/datePlan` APIのみを叩き続けるものであり、DBには100,000件のデータが入っている。

Requests/secで表されるスループットはおよそ４件。
また、Detailsのresp waitで表されるGoプログラムとDBの合計処理時間の合計はおよそ12秒であることがわかった。

単純にデータを一件返すだけのAPIであることを考えるとこの速度には改善の余地があると考えられる。

ここで、現在のSQL文に注目する。

`SELECT id, title, content FROM datePlans ORDER BY RANDOM() LIMIT 1`

ボトルネックになっているのは `ORDER BY　RANDOM()` の部分であると考えられる。

この部分で何が起こっているのか述べる。まず、DBは対象のデータ群に対して[ランダムな数値｜対象データ]という形で一つ一つにペアを作り、それをメモリ上に作ったB-Treeに放り込んでソートする（対象データが重い場合はランダムな数値のみがメモリに来る）。そして、一番値が小さい一件のみを抽出し、それを返す。

データ数を $N$ とすれば、これは $O(NlogN)$ の計算量がかかる。また、メモリ使用量も $O(N)$である。実際にはメモリにデータが乗り切らずストレージとスワップしながらソートする可能性もあり、さらなるパフォーマンスもありうる。

改めて、ただ一件のみを抽出するためだけにこの計算量とメモリ使用量を消費するのは非効率である。

ただしこの速度をB-treeインデックスで解決することはできない。なぜならば並べ替えはランダムであり、既存のB-treeはランダムソートをスキップすることができないからだ。

したがってデータ自体を並べ替えるのではなく、`id` を一件ランダムに指定して一件のみDBから抽出するという方法が適切であると考える。

SQL文は以下のようになる。

`SELECT COUNT(id) FROM datePlans`

`SELECT id, title, content FROM datePlans WHERE id = ?`

一文目は現在の行数をチェックするもの。その行数を利用して、ランダムに対象となるIDを生成する。

二文目はそのIDに該当するデータを得るもの。

これらを反映して、同様に合計アクセス数2000件、同時接続数50人という条件で負荷テストを行った結果が以下である。

```
Summary:
  Total:        97.6657 secs
  Slowest:      5.2664 secs
  Fastest:      0.1082 secs
  Average:      2.4029 secs
  Requests/sec: 20.4780
  
  Total data:   411071 bytes
  Size/request: 205 bytes

Response time histogram:
  0.108 [1]     |
  0.624 [9]     |■
  1.140 [15]    |■
  1.656 [32]    |■■
  2.171 [702]   |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  2.687 [630]   |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  3.203 [524]   |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  3.719 [43]    |■■
  4.235 [19]    |■
  4.751 [14]    |■
  5.266 [11]    |■


Latency distribution:
  10%% in 1.8462 secs
  25%% in 1.9730 secs
  50%% in 2.3692 secs
  75%% in 2.7806 secs
  90%% in 2.9358 secs
  95%% in 3.1248 secs
  99%% in 4.3707 secs

Details (average, fastest, slowest):
  DNS+dialup:   0.0001 secs, 0.0000 secs, 0.0066 secs
  DNS-lookup:   0.0001 secs, 0.0000 secs, 0.0026 secs
  req write:    0.0000 secs, 0.0000 secs, 0.0004 secs
  resp wait:    2.4028 secs, 0.1082 secs, 5.2663 secs
  resp read:    0.0000 secs, 0.0000 secs, 0.0024 secs

Status code distribution:
  [200] 2000 responses
```

スループットは20件となり5倍のパフォーマンス。

平均処理時間は2.4秒となりこれも5倍のパフォーマンスである。

これは大きな改善であると言える。

これらSQL文の計算量は、一文目に対して $O(N)$, 二文目に対して $O(1)$ であり、パフォーマンスの伸びに対応していると言える。


デートプランを取得するたびに行数を計算するのは非効率なため、それらの操作を切り離す必要がある。
今回は行数をglobal variableとして保持することでそれを解決した。

```
Summary:
  Total:        0.0723 secs
  Slowest:      0.0106 secs
  Fastest:      0.0000 secs
  Average:      0.0017 secs
  Requests/sec: 27644.4666
  
  Total data:   411410 bytes
  Size/request: 205 bytes

Response time histogram:
  0.000 [1]     |
  0.001 [930]   |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  0.002 [482]   |■■■■■■■■■■■■■■■■■■■■■
  0.003 [272]   |■■■■■■■■■■■■
  0.004 [167]   |■■■■■■■
  0.005 [86]    |■■■■
  0.006 [35]    |■■
  0.007 [10]    |
  0.008 [14]    |■
  0.010 [1]     |
  0.011 [2]     |


Latency distribution:
  10%% in 0.0001 secs
  25%% in 0.0005 secs
  50%% in 0.0012 secs
  75%% in 0.0025 secs
  90%% in 0.0038 secs
  95%% in 0.0048 secs
  99%% in 0.0071 secs

Details (average, fastest, slowest):
  DNS+dialup:   0.0000 secs, 0.0000 secs, 0.0023 secs
  DNS-lookup:   0.0000 secs, 0.0000 secs, 0.0014 secs
  req write:    0.0000 secs, 0.0000 secs, 0.0004 secs
  resp wait:    0.0016 secs, 0.0000 secs, 0.0085 secs
  resp read:    0.0000 secs, 0.0000 secs, 0.0005 secs

Status code distribution:
  [200] 2000 responses
```

行数の計算が一回きりになったため、パフォーマンスが大幅に向上した。

## 2/20　SQL文変更による欠番への対処とページキャッシュを用いたパフォーマンスの維持。
更新と削除機能の追加を行なった。

その結果、今まで使っていた`id` の指定方法が使えなくなる。つまり、ランダムに`id`を指定していては削除されてしまった`id`を指定してしまう可能性があるのだ。

この問題の解決方法は二つ存在する。

1. 成功するまで`id`をランダムに取得し続ける。

2. `id`の周辺にある一番近い要素を指定する。

方法１の場合SQL文を多く発行しかねないため、一回の発行で済む方法２を採用する。

方法２の場合、初めに考えられるSQL文は以下のものである。

`SELECT id, title, content FROM datePlans WHERE id >= ? ORDER BY id ASC LIMIT 1;`

これは指定された`id`と同じか、それより大きく一番近い`id`を持つ行を一つ抽出するSQL文である。

主キーである`id`にはインデックスが貼られているため、このSQL文の場合そのB-treeを利用することができる。つまりメモリ上でソートする必要がなく、B-tree走査分の $O(logN)$ で走らせることができる。

具体的には、OSがストレージからメモリへ１ページ（Apple Siliconの場合16KB）コピーし、そのページ内に収まるデータから存在するデータを探し、あればそれをプログラムに返す。

「存在するデータ」というのは、DBからデータを削除した直後はすぐにその穴が他のデータに埋められるわけではなく、どこかの時点でデータが埋めにくるまでずっと穴のままなので、ページを取ってきても最初の方はデータが存在しないということがありうるのである。

ただしB-treeの方からは削除されたデータの`id`は削除されているため、削除されたデータをプログラムに返してしまうということはない。

また、どのページを取ってくるか決めているのもB-treeである。つまり、メモリ上にあるB-treeから対象となる`id`を探し、「その`id`がついているデータはこの辺にあるね」と判断してOSにとってこさせる。

次にエッジケースへの対処に移る。上記のSQL文が考慮していないのは`id`以上のデータが一切存在しないケースである。

その場合は以下のSQL文を発行することにする。

`SELECT id, title, content FROM datePlans WHERE id <= ? ORDER BY id DSC LIMIT 1;`

このSQL文は大きくパフォーマンスを悪化させないと考える。なぜならば、このSQL文はページキャッシュを利用できるからだ。

一つ目のSQLが失敗する場合というのは、つまり存在する`id`に対して指定された`id`が大きすぎる場合のことである。

その場合、B-treeは指定できるページの中で最もその`id`に近いページを指定し、それをメモリに持ってきて探し始める。例えば現在持っている最大`id`が 500, 指定された`id`が 600 だとすれば、`id`が500 のデータが入っているページを持ってきて探し始める。

ただしもちろん対象の`id`は存在しないので、一つ目のSQLは失敗することになる。

ここで二つ目のSQLに移るが、注目すべきは二つ目のSQLはページキャッシュを利用できるということだ。

なぜならば一つ目のSQLがページを引っ張ってきたことで、そのページがメモリ上のキャッシュに保存されているからである。結果二つ目のSQLはI/O無しで、B-tree走査とページの中を探すだけで計算を終了できる。

したがって、このケースではSQL文を１つ発行しようと２つ発行しようと処理時間はほとんど変わらないと考えられる。


